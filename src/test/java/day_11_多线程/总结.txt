1. 多线程
    多线程程序，就相当于你正在干活，另一件事情，也必须同时进行，那么就可以找另一个人来帮你干。

    多线程 == 不安全。
        错的！
        不是说多线程就一定不安全。

    进程：
        就是正在内存中运行的，一个一个的应用程序。
    线程：
        就是进程中，负责执行代码的一个一个的执行单元。

    并发：
        一个时间段内，多件事情，交替执行。【单核cpu实现的多个任务（多个任务高速切换交替执行），厨房里一个厨师在多个灶台上快速切换炒着多个菜】
    并行：
        同一个时刻，多件事情，同时执行。【多核CPU同一时刻，多个任务执行。厨房多个厨师，每个厨师专注于炒一个菜】

    实现多线程程序：
        1. 继承Thread类
            自定义一个类，继承Thread,重写run()方法，在测试类中，创建该类对象，调用start()方法开启线程。

            注意：
                1. 一定要重写run()方法；
                2. 调用start()方法才能开启线程。

        2. 实现Runnable接口   【执行完毕后，直接结束，没有结果】
            自定义一个类，实现Runnable接口,重写run()方法，在测试类中，创建该类对象，再创建Thread类的对象，
            通过Thread构造方法，将自定义类对象传入，通过Thread类对象，调用start()方法开启线程。

        3. 实现Callable接口   【执行完毕后，直接结束，可以获得结果】
            1. 自定义一个类，实现Callable接口,重写call()方法。
            2. 创建该类对象
            3. 再创建FutureTask对象，将自定义对象，传入FutureTask对象的构造方法。
            4. 再创建Thread对象，将FutureTask对象，传入Thread对象的构造方法。
            5. 通过Thread对象调用start()开启线程。
            6. 通过FutureTask对象，调用get()方法，获取运行的结果。


        Java对多线程的调度模式：抢占式。
            谁抢到，就谁执行。
            可以通过设置线程的优先级，来提高该线程被抢到的概率。
             setPriority(5);默认优先级是5，优先级范围：1——10

        守护线程：
            为了其他线程而存在的线程，当被守护的线程执行完毕，那么守护线程也会随之停止。
            setDaemon(true);

    成员方法：
        getName();            获取线程名称。
        setName(String name); 设置线程名称。
	继承Thread类的子类可以直接使用getName()方法， 设置thread的空参、带参构造方法，可以设置线程的名称(一般不用)。
	实现Runnable、callAble接口的子类，需要通过 Thread.currentThread().getName()方法来获取当前线程的名字。

    多线程，访问同一对象中的成员变量。

    同步：  线程安全问题(数据)
        同步代码块：
            synchronized(锁对象){
                需要被同步的代码。
            }
            注意：必须保证锁对象唯一。
	如何保证锁对象唯一？
	      (static Object obj = new Object()):通过static关键字修饰，锁对象可以是任意的对象，单必须保证唯一，否则就失去了加锁的意义。()

        同步方法：   【了解】
            非静态方法：
                this
            静态方法：
                该类的字节码对象。【类名.class】

        synchronized:
            升级之前：只要是多线程程序，加上同步，没有进入同步的线程，就会调用系统的方法，对线程进行挂起。
                执行的线程，执行完毕之后，才会由系统唤醒被挂起的线程，来争夺锁对象。

        现在：JDK 对亲儿子synchronized做了升级。
                无锁。
                偏向锁：
                    当同步方法或者同步代码块，只有一条线程在执行，JVM就是偏向第一个获得该锁对象的线程，
                    下次这个哥们再来，就无需再次判断锁了。
                    当有其他线程与之竞争时，就会自动升级成轻量级锁。
                轻量级锁：
                    当有其他线程在竞争时，没有获得锁对象的线程，会做自适应自旋(循环)，就相当于在门口等一会，实在等不了了，就走了。
                    上面的实在等不了了，就是自动升级成重量级锁。
                重量级锁：
                    就是系统挂起线程。

                注意：
                    上面的几种状态，只能升级，不能降级。

        Lock:
	创建对象：Lock lock= new ReentrantLock();【多态创建】
	手动上锁【lock.lock( )】，手动释放锁【lock.unlock()】
            java层面的锁机制，判断对象中的一个变量state是否为0或者1.
                0:无人。
                1:有人。

            公平锁：
                如果锁被占用，则进入阻塞队列等待。
            非公平锁：
                如果锁被占用，在外面等一会，刚好锁被释放，则不进入阻塞队列，而是同阻塞队列中出来的线程，争夺锁对象。
      
        死锁：
	锁嵌套，最终导致出现死锁
	如：有锁对象A和锁对象B，
		线程一先使用sychronized(A)，再使用sychronized(B)。【A对象会被锁住，等待B对象开锁】
		线程二先使用sychronized(B)，再使用sychronized(A)。	【B对象会被锁住，等待A对象开锁】
			最终会导致两个线程都无法往下执行，从而出现锁死。
    线程之间的通信：
        等待唤醒机制。
            必须是用一个监视器(锁对象)上，才能唤醒。

        包子铺和吃货。

    wait()和sleep()的区别？
        wait()：（notify()唤醒一个等待的线程，notifyAll()唤醒所有等待的线程）
            1. 一定会释放锁对象。
            2. Object类中的方法。
            3. wait()和notify()方法，必须使用在同中，等待和唤醒，都必须是同一个锁对象。
            4. 调用wait()的线程，如果没有其他线程唤醒，永远醒不来。
        sleep():
            1. 不会放弃锁对象。
            2. Thread类中的方法。
            3. 任何地方都可以使用。
            4. sleep()时间到了，会自动醒来。

